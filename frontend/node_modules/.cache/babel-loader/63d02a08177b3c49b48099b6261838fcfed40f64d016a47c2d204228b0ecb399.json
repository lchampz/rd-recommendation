{"ast":null,"code":"// recommendation.service.js\n\nconst getRecommendations = (formData = {\n  selectedPreferences: [],\n  selectedFeatures: []\n}, products = [], oneProduct = false) => {\n  const {\n    selectedPreferences,\n    selectedFeatures\n  } = formData;\n\n  // Se não há produtos, retorna array vazio\n  if (!products || products.length === 0) {\n    return oneProduct ? null : [];\n  }\n\n  // Se não há seleções, retorna todos os produtos ordenados por categoria\n  if ((!selectedPreferences || selectedPreferences.length === 0) && (!selectedFeatures || selectedFeatures.length === 0)) {\n    const sortedProducts = [...products].sort((a, b) => a.category.localeCompare(b.category));\n    return oneProduct ? sortedProducts[0] : sortedProducts;\n  }\n\n  // Calcula pontuação para cada produto\n  const productsWithScore = products.map(product => {\n    let score = 0;\n\n    // Pontuação por preferências (peso: 3)\n    if (selectedPreferences && selectedPreferences.length > 0) {\n      const preferencesMatched = selectedPreferences.filter(pref => product.preferences.includes(pref)).length;\n      score += preferencesMatched * 3;\n    }\n\n    // Pontuação por funcionalidades (peso: 2)\n    if (selectedFeatures && selectedFeatures.length > 0) {\n      const featuresMatched = selectedFeatures.filter(feature => product.features.includes(feature)).length;\n      score += featuresMatched * 2;\n    }\n\n    // Bônus por produtos que atendem tanto preferências quanto funcionalidades\n    if (score > 0) {\n      score += 5;\n    }\n\n    // Bônus por produtos com mais matches totais\n    const totalMatches = (selectedPreferences || []).filter(pref => product.preferences.includes(pref)).length + (selectedFeatures || []).filter(feature => product.features.includes(feature)).length;\n    if (totalMatches > 0) {\n      score += totalMatches * 2;\n    }\n    return {\n      ...product,\n      score,\n      preferencesMatched: selectedPreferences ? selectedPreferences.filter(pref => product.preferences.includes(pref)).length : 0,\n      featuresMatched: selectedFeatures ? selectedFeatures.filter(feature => product.features.includes(feature)).length : 0,\n      totalMatches: totalMatches\n    };\n  });\n\n  // Filtra produtos com pontuação > 0 e ordena por score (maior primeiro)\n  const recommendations = productsWithScore.filter(product => product.score > 0).sort((a, b) => {\n    // Primeiro ordena por score\n    if (b.score !== a.score) {\n      return b.score - a.score;\n    }\n    // Em caso de empate, ordena por total de matches\n    if (b.totalMatches !== a.totalMatches) {\n      return b.totalMatches - a.totalMatches;\n    }\n    // Em caso de empate, ordena por categoria\n    return a.category.localeCompare(b.category);\n  });\n\n  // Remove propriedades de score para não poluir o objeto\n  const cleanRecommendations = recommendations.map(({\n    score,\n    preferencesMatched,\n    featuresMatched,\n    totalMatches,\n    ...product\n  }) => product);\n  return oneProduct ? cleanRecommendations[0] : cleanRecommendations;\n};\nexport default {\n  getRecommendations\n};","map":{"version":3,"names":["getRecommendations","formData","selectedPreferences","selectedFeatures","products","oneProduct","length","sortedProducts","sort","a","b","category","localeCompare","productsWithScore","map","product","score","preferencesMatched","filter","pref","preferences","includes","featuresMatched","feature","features","totalMatches","recommendations","cleanRecommendations"],"sources":["/Users/victor/Documents/dev/monorepo/frontend/src/services/recommendation.service.js"],"sourcesContent":["// recommendation.service.js\n\nconst getRecommendations = (\n  formData = { selectedPreferences: [], selectedFeatures: [] },\n  products = [],\n  oneProduct = false\n) => {\n  const { selectedPreferences, selectedFeatures } = formData;\n\n  // Se não há produtos, retorna array vazio\n  if (!products || products.length === 0) {\n    return oneProduct ? null : [];\n  }\n\n  // Se não há seleções, retorna todos os produtos ordenados por categoria\n  if ((!selectedPreferences || selectedPreferences.length === 0) &&\n    (!selectedFeatures || selectedFeatures.length === 0)) {\n    const sortedProducts = [...products].sort((a, b) => a.category.localeCompare(b.category));\n    return oneProduct ? sortedProducts[0] : sortedProducts;\n  }\n\n  // Calcula pontuação para cada produto\n  const productsWithScore = products.map(product => {\n    let score = 0;\n\n    // Pontuação por preferências (peso: 3)\n    if (selectedPreferences && selectedPreferences.length > 0) {\n      const preferencesMatched = selectedPreferences.filter(pref =>\n        product.preferences.includes(pref)\n      ).length;\n      score += preferencesMatched * 3;\n    }\n\n    // Pontuação por funcionalidades (peso: 2)\n    if (selectedFeatures && selectedFeatures.length > 0) {\n      const featuresMatched = selectedFeatures.filter(feature =>\n        product.features.includes(feature)\n      ).length;\n      score += featuresMatched * 2;\n    }\n\n    // Bônus por produtos que atendem tanto preferências quanto funcionalidades\n    if (score > 0) {\n      score += 5;\n    }\n\n    // Bônus por produtos com mais matches totais\n    const totalMatches = (selectedPreferences || []).filter(pref =>\n      product.preferences.includes(pref)\n    ).length + (selectedFeatures || []).filter(feature =>\n      product.features.includes(feature)\n    ).length;\n\n    if (totalMatches > 0) {\n      score += totalMatches * 2;\n    }\n\n    return {\n      ...product,\n      score,\n      preferencesMatched: selectedPreferences ? selectedPreferences.filter(pref =>\n        product.preferences.includes(pref)\n      ).length : 0,\n      featuresMatched: selectedFeatures ? selectedFeatures.filter(feature =>\n        product.features.includes(feature)\n      ).length : 0,\n      totalMatches: totalMatches\n    };\n  });\n\n  // Filtra produtos com pontuação > 0 e ordena por score (maior primeiro)\n  const recommendations = productsWithScore\n    .filter(product => product.score > 0)\n    .sort((a, b) => {\n      // Primeiro ordena por score\n      if (b.score !== a.score) {\n        return b.score - a.score;\n      }\n      // Em caso de empate, ordena por total de matches\n      if (b.totalMatches !== a.totalMatches) {\n        return b.totalMatches - a.totalMatches;\n      }\n      // Em caso de empate, ordena por categoria\n      return a.category.localeCompare(b.category);\n    });\n\n  // Remove propriedades de score para não poluir o objeto\n  const cleanRecommendations = recommendations.map(({ score, preferencesMatched, featuresMatched, totalMatches, ...product }) => product);\n\n  return oneProduct ? cleanRecommendations[0] : cleanRecommendations;\n};\n\nexport default { getRecommendations };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}